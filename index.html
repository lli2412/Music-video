<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>p5.js Music Visualizer</title>
  <style>
    body, html { margin:0; padding:0; overflow:hidden; background:black; }
    canvas { display:block; }
    #controls {
      position: absolute;
      top: 10px; left: 10px;
      z-index: 10;
      color: white;
      font-family: sans-serif;
    }
    #controls input, #controls select {
      margin: 5px 0;
      display: block;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script>
</head>
<body>
<div id="controls">
  <input type="file" id="fileInput" accept="audio/*">
  <label for="skinSelect">üé® Skin:</label>
  <select id="skinSelect">
    <option value="neon">Neon</option>
    <option value="ice">Ice</option>
    <option value="retro">Retro</option>
  </select>
</div>
<script>
let song, fft, amp;
let mode = 0;
let modes = ["spectrum", "waveform", "fractal", "waterfall", "particles"];
let peaks = [];
let particles = [];
let skin = "neon";

function setup() {
  createCanvas(windowWidth, windowHeight);
  colorMode(HSB, 360, 255, 255);
  fft = new p5.FFT(0.8, 1024);
  amp = new p5.Amplitude();

  for (let i=0;i<64;i++) peaks[i]=0;
  for (let i=0;i<300;i++) {
    particles.push({ x: width/2, y: height/2, vx: random(-1,1), vy: random(-1,1), life: random(50,200) });
  }

  canvas.addEventListener("click", () => {
    mode = (mode + 1) % modes.length;
  });

  document.getElementById("fileInput").addEventListener("change", e => {
    if (song && song.isPlaying()) song.stop();
    let file = e.target.files[0];
    if (file) song = loadSound(URL.createObjectURL(file), () => song.play());
  });

  document.getElementById("skinSelect").addEventListener("change", e => {
    skin = e.target.value;
  });
}

function draw() {
  if (!song) {
    background(0);
    fill(255);
    textAlign(CENTER, CENTER);
    textSize(24);
    text("–í—ã–±–µ—Ä–∏ —Ç—Ä–µ–∫ —Å–≤–µ—Ä—Ö—É üéµ", width/2, height/2);
    return;
  }

  if (modes[mode]!=="waterfall") background(0,40);
  let spectrum = fft.analyze();
  let waveform = fft.waveform();
  let level = amp.getLevel();

  if (modes[mode]==="spectrum") drawSpectrum(spectrum);
  else if (modes[mode]==="waveform") drawWaveform(waveform);
  else if (modes[mode]==="fractal") drawFractal(spectrum);
  else if (modes[mode]==="waterfall") drawWaterfall(spectrum);
  else if (modes[mode]==="particles") drawParticles(level);

  fill(255);
  textSize(16);
  textAlign(LEFT,TOP);
  text("Mode: "+modes[mode]+" | Skin: "+skin, 10,10);
}

// === –¶–≤–µ—Ç–æ–≤—ã–µ –ø–∞–ª–∏—Ç—Ä—ã ===
function getColor(i, max, val=1) {
  if (skin==="neon") return color((i/max*360 + millis()/30)%360, 255, 255*val);
  if (skin==="ice")  return color(180 + (i%60), 80, 255*val);
  if (skin==="retro") return color((i*7)%360, 150, 200*val);
  return color(255);
}

// === Spectrum with peaks ===
function drawSpectrum(spectrum) {
  let bins = 64, step = floor(spectrum.length/bins);
  for (let i=0;i<bins;i++) {
    let val = spectrum[i*step]/255;
    let h = val*height;
    fill(getColor(i,bins,val));
    rect(i*(width/bins), height-h, width/bins, h);
    if (val > peaks[i]) peaks[i]=val;
    else peaks[i]=max(0, peaks[i]-0.01);
    fill(0,0,255);
    rect(i*(width/bins), height-peaks[i]*height-4, width/bins, 4);
  }
}

// === Waveform ===
function drawWaveform(waveform) {
  noFill(); stroke(getColor(0,1,1)); strokeWeight(2);
  beginShape();
  for (let i=0;i<waveform.length;i++) {
    let x = map(i,0,waveform.length,0,width);
    let y = map(waveform[i],-1,1,0,height);
    vertex(x,y);
  }
  endShape();
}

// === Fractal spiral ===
function drawFractal(spectrum) {
  translate(width/2,height/2);
  noStroke();
  let avg = spectrum.reduce((a,b)=>a+b,0)/spectrum.length;
  let pulse = 1+avg/200;
  for (let i=0;i<spectrum.length;i++) {
    let angle = i*0.1;
    let radius = i*1.5*pulse;
    let x = cos(angle)*radius, y = sin(angle)*radius;
    fill(getColor(i,spectrum.length,avg/255));
    ellipse(x,y,2+avg/100);
  }
}

// === Waterfall ===
function drawWaterfall(spectrum) {
  copy(0,0,width,height,0,-2,width,height);
  let bins = 128, step = floor(spectrum.length/bins);
  for (let i=0;i<bins;i++) {
    let val = spectrum[i*step]/255;
    stroke(getColor(i,bins,val));
    line(i*(width/bins), height, (i+1)*(width/bins), height);
  }
}

// === Particles ===
function drawParticles(level) {
  noStroke();
  for (let p of particles) {
    p.x += p.vx*(1+level*10);
    p.y += p.vy*(1+level*10);
    p.life--;
    if (p.life<=0 || p.x<0||p.x>width||p.y<0||p.y>height) {
      p.x=width/2; p.y=height/2;
      p.vx=random(-2,2); p.vy=random(-2,2);
      p.life=random(100,200);
    }
    fill(getColor(p.x,width,level));
    ellipse(p.x,p.y,4+level*20);
  }
}
</script>
</body>
</html>
